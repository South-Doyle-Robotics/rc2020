from tools import Timer
from math import degrees, radians, pi
from traits import DriveTrain, Gyro
from wpilib.controller import RamseteController
from wpilib.kinematics import DifferentialDriveOdometry, DifferentialDriveKinematics
from wpilib.geometry import Rotation2d, Pose2d


class PathfinderController:
    def __init__(self, kS, kV, trackwidth, starting_x, starting_y, starting_angle):
        '''
        Creates a controller for following a PathWeaver trajectory.

        __init__(self, kS: Volts, kV: Volts * Seconds / Meters, trackwidth: Meters, starting_x: Meters, starting_y: Meters, starting_angle: Degrees)

        :param kS: The kS gain determined by characterizing the Robot's drivetrain
        :param kV: The kV gain determined by characterizing the Robot's drivetrain
        :param starting_x: The starting x position of the robot (the x coordinate of the first point of the path in PathWeaver)
        :param starting_y: The starting y position of the robot (the y coordinate of the first point of the path in PathWeaver)
        :param starting_angle: The angle of the robot in degrees
        '''

        self.kS = kS
        self.kV = kV
        self.starting_angle = starting_angle

        self.starting_position = Pose2d(
            starting_x, starting_y, Rotation2d(radians(self.starting_angle)))

        self.odometry = DifferentialDriveOdometry(
            Rotation2d(radians(0)), self.starting_position)

        self.ramsete = RamseteController(2, 0.7)
        self.drive_kinematics = DifferentialDriveKinematics(trackwidth)

        self.trajectory = None
        self.timer = Timer()

    def reset(self, chassis, gyro):
        '''
        Re-initializes all of the data in the controller as if the path has not yet been executed.
        This method MUST be called in teleopInit and autonomousInit directly before the controller is used.


        reset(self, chassis: traits.DriveTrain, gyro: traits.Gyro)

        :param chassis: An object that implements the DriveTrain trait. This object's encoders will be reset by this function
        :param gyro: An object that implements the Gyro trait. This object's angle will be reset by this function
        '''

        # Assert the objects implement the proper traits
        assert chassis.implements(DriveTrain)
        assert gyro.implements(Gyro)

        chassis.reset_encoders()
        gyro.reset()
        self.odometry = DifferentialDriveOdometry(
            Rotation2d(radians(0)), self.starting_position)

        self.timer.start()

    def set_trajectory(self, trajectory):
        '''
        Sets the trajectory to be used for calculating the motor speeds.

        set_trajectory(self, trajectory: wpilib.trajectory.Trajectory)

        :param trajectory: The trajectory to follow. This can be generated by PathWeaver, or made by hand.
        '''
        self.trajectory = trajectory

    def update(self, chassis, gyro):
        '''
        This updates the PathfinderController and drives the chassis to follow the path

        update(self, chassis: traits.DriveTrain, gyro: traits.Gyro)

        :param chassis: An object that implements the DriveTrain trait. When this function is called,
                        the object's motors will be driven to follow the last set trajectory.
        :param gyro: An object that implements the gyro trait.
        '''
        # Assert the objects implement the proper traits
        assert chassis.implements(DriveTrain)
        assert gyro.implements(Gyro)

        # Set the chassis to low gear for more precise movements
        chassis.set_low_gear()

        # If a trajectory has been set, run it
        if self.trajectory is not None:
            # Get the accumulated left and right distance of the chass
            ld, rd = chassis.get_left_distance(), chassis.get_right_distance()

            # Ramsete requires the counterclockwise angle of the Robot
            angle = gyro.get_counterclockwise_degrees()

            # Get the current position of the robot
            current_pose = self.odometry.update(
                Rotation2d(radians(angle)),
                ld, rd
            )

            # Calculate the target position using the trajectory, and get the chassis wheel speeds
            target_pose = self.trajectory.sample(self.timer.get())
            chassis_speed = self.ramsete.calculate(current_pose, target_pose)
            wheel_speeds = self.drive_kinematics.toWheelSpeeds(chassis_speed)
            l, r = wheel_speeds.left, wheel_speeds.right

            # Convert the left and right wheel speeds to volts using the characterized constants,
            # and then convert those to percent values from -1 to 1
            chassis.tank_drive((self.kS + l*self.kV)/12,
                               (self.kS + r*self.kV)/12)
